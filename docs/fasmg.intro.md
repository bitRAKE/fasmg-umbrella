# What is flat assembler g?

It is an assembly engine designed as a successor to the one used in flat assembler 1, a well-regarded assembler for x86 processors. This is a bare engine, lacking the built-in ability to recognize and encode instructions for any specific processor. However, it is designed to be adaptable and can become an assembler for any CPU architecture. It features a significantly improved macroinstruction language compared to flat assembler 1, allowing for the easy implementation of instruction encoders as customizable macroinstructions.

The source code of flat assembler g can be compiled with flat assembler 1, and also with flat assembler g itself. The source includes clauses that conditionally include different header files depending on the assembler used for compilation. When flat assembler g compiles itself, it utilizes a provided set of headers that implement x86 instructions and formats, with a syntax mostly compatible with flat assembler 1.

The example programs for the x86 architecture included in this package are selected samples originally from flat assembler 1. They use header sets that implement instruction encoders and output formatters, allowing them to be assembled just like in the original flat assembler.

To demonstrate the implementation of instruction sets for different architectures, example programs for the 8051 and AVR microcontrollers are provided. These examples are intentionally simple and do not offer a complete programming framework for these CPUs. However, they can serve as a solid foundation for creating such environments.

An example of assembling JVM bytecode is also included, which is a conversion of a sample originally created for flat assembler 1.  While somewhat basic and not fully utilizing the new engine's capabilities, it effectively visualizes the structure of a class file.

<br>

# How does this work?

The fundamental function of flat assembler g is to generate output as defined by the instructions in the source code. For example, the following line of code:

```assembly
db 90h
```

will instruct the assembler to generate a single byte with the hexadecimal value `90h`.

Macroinstructions can be defined to generate specific sequences of data based on provided parameters. These macroinstructions can represent instructions of a chosen machine language, as shown below, or be designed to generate other types of data for various purposes.

```assembly
macro int number
    if number = 3
        db 0CCh
    else
        db 0CDh, number
    end if
end macro

int 20h         ; generates two bytes
```

Assembly, viewed this way, can be considered a form of interpreted language, and the assembler indeed shares many characteristics with an interpreter. However, it also exhibits aspects of a compiler. An instruction can use a value defined later in the source code, potentially dependent on preceding instructions. This is illustrated in the following example:

```assembly
macro jmpi target
    if target-($+2) < 80h & target-($+2) >= -80h
        db 0EBh
        db target-($+1)
    else
        db 0E9h
        dw target-($+2)
    end if
end macro

        jmpi start
        db 'some data'
start:
```

The macro `jmpi` defined above generates the code for a jump instruction, similar to those in the 8086 architecture. This code includes a relative offset to the jump target, stored as either a single byte or a 16-bit word. The relative offset is calculated as the difference between the target address and the address of the instruction immediately following the jump. The special symbol `$` represents the address of the current instruction and is used to calculate the relative offset and determine if it fits within a single byte.

Therefore, the code generated by `jmpi start` in the example depends on the address labeled `start`.  The address of `start`, in turn, is affected by the length of the output from all preceding instructions, including the `jmpi` instruction itself. This creates a circular dependency, and the assembler must find a solution that satisfies all constraints imposed by the source text. This capability distinguishes it from a purely imperative interpreter and introduces declarative aspects to its language.

Resolving such circular dependencies can be likened to solving an equation.  Flat assembler g can even solve some equations directly within the assembly source:

```assembly
x = (x-1)*(x+2)/2-2*(x+1)
db x
```

Here, the circular reference is reduced to a single definition that references itself to determine its value. Flat assembler g can find a solution in this case, although it may fail in more complex scenarios. The assembler's method involves performing multiple passes through the source text to gather information and then attempting to predict all values based on this knowledge. While this approach is generally effective for assembling machine code, it is rarely sufficient for solving complex equations, making the example above an exception.

<br>

# What are the means of parsing the arguments of an instruction?

Not all instructions have simple syntax like those in the previous examples. To facilitate processing arguments that may contain special constructions, flat assembler g provides several powerful tools. These are demonstrated below using examples that implement a few selected instructions of the Z80 processor.  Detailed rules for using these features are available in the manual.

When an instruction has a limited set of allowed arguments, each argument can be handled separately using the `match` construction:

```assembly
macro EX? first,second
    match (=SP?), first
        match =HL?, second
            db 0E3h
        else match =IX?, second
            db 0DDh,0E3h
        else match =IY?, second
            db 0FDh,0E3h
        else
            err "incorrect second argument"
        end match
    else match =AF?, first
        match =AF'?, second
            db 08h
        else
            err "incorrect second argument"
        end match
    else match =DE?, first
        match =HL?, second
            db 0EBh
        else
            err "incorrect second argument"
        end match
    else
        err "incorrect first argument"
    end match
end macro

EX (SP),HL
EX (SP),IX
EX AF,AF'
EX DE,HL
```

The `?` character, used in several places, denotes case-insensitivity for names. Removing these would further simplify the example.

When an argument can take a larger set of values with some regularity, textual substitutions can be defined to replace symbols with carefully chosen constructions that can then be recognized and parsed:

```assembly
A? equ [:111b:]
B? equ [:000b:]
C? equ [:001b:]
D? equ [:010b:]
E? equ [:011b:]
H? equ [:100b:]
L? equ [:101b:]

macro INC? argument
    match [:r:], argument
        db 100b + r shl 3
    else match (=HL?), argument
        db 34h
    else match (=IX?+d), argument
        db 0DDh,34h,d
    else match (=IY?+d), argument
        db 0FDh,34h,d
    else
        err "incorrect argument"
    end match
end macro

INC A
INC B
INC (HL)
INC (IX+2)
```

This approach has a potential drawback: it allows expressions like `[:0:]` directly within arguments. To prevent such unintended syntax, a prefix can be used in the `match` construction:

```assembly
REG.A? equ [:111b:]
REG.B? equ [:000b:]
REG.C? equ [:001b:]
REG.D? equ [:010b:]
REG.E? equ [:011b:]
REG.H? equ [:100b:]
REG.L? equ [:101b:]

macro INC? argument
    match [:r:], REG.argument
        db 100b + r shl 3
    else match (=HL?), argument
        db 34h
    else match (=IX?+d), argument
        db 0DDh,34h,d
    else match (=IY?+d), argument
        db 0FDh,34h,d
    else
        err "incorrect argument"
    end match
end macro
```

For arguments structured like `(IX+d)`, it might be desirable to allow algebraically equivalent forms, such as `(d+IX)` or `(c+IX+d)`. Instead of parsing each variant individually, the assembler can evaluate the expression while treating a selected symbol distinctly. Declaring a symbol as an `element` gives it no inherent value. When used in an expression, it is treated algebraically as a variable term in a polynomial.

```assembly
element HL?
element IX?
element IY?

macro INC? argument
    match [:r:], REG.argument
        db 100b + r shl 3
    else match (a), argument
        if a eq HL
            db 34h
        else if a relativeto IX
            db 0DDh,34h,a-IX
        else if a relativeto IY
            db 0FDh,34h,a-IY
        else
            err "incorrect argument"
        end if
    else
        err "incorrect argument"
    end match
end macro

INC (3*8+IX+1)

virtual at IX
    x db ?
    y db ?
end virtual

INC (y)
```

A minor issue with the above macroinstruction is that a parameter can contain arbitrary text. When such a value is used in an expression, it can lead to unexpected behavior. For example, `INC (1|0)` would incorrectly evaluate `a eq HL` as `1|0 eq HL`, which is a valid and true logical expression, even though the argument is malformed. This side-effect stems from macroinstructions operating via simple text substitution. (Using CALM instructions is a better approach to avoid such issues.) To prevent this, a local variable can act as a proxy to hold the argument's value:

```assembly
macro INC? argument
    match [:r:], REG.argument
        db 100b + r shl 3
    else match (a), argument
        local value
        value = a
        if value eq HL
            db 34h
        else if value relativeto IX
            db 0DDh,34h,a-IX
        else if value relativeto IY
            db 0FDh,34h,a-IY
        else
            err "incorrect argument"
        end if
    else
        err "incorrect argument"
    end match
end macro
```

Using a proxy variable offers an additional benefit: its value is computed *before* the macroinstruction begins generating output. When an expression includes a symbol like `$`, its value can differ depending on when it's evaluated. The proxy variable ensures the value is taken from the argument evaluation *before* instruction code generation.

When dealing with a larger set of symbols in expressions, it is more efficient to use a single construct to process a family of them. An `element` declaration can associate an additional value with a symbol. This information can be retrieved using the `metadata` operator applied to a linear polynomial containing the symbol as a variable. The following example is another version of the previous macroinstruction, demonstrating this feature:

```assembly
element register
element A? : register + 111b
element B? : register + 000b
element C? : register + 001b
element D? : register + 010b
element E? : register + 011b
element H? : register + 100b
element L? : register + 101b

element HL?
element IX?
element IY?

macro INC? argument
    local value
    match (a), argument
        value = a
        if value eq HL
            db 34h
        else if value relativeto IX
            db 0DDh,34h,a-IX
        else if value relativeto IY
            db 0FDh,34h,a-IY
        else
            err "incorrect argument"
        end if
    else match any more, argument
        err "incorrect argument"
    else
        value = argument
        if value eq value element 1 & value metadata 1 relativeto register
            db 100b + (value metadata 1 - register) shl 3
        else
            err "incorrect argument"
        end if
    end match
end macro
```

The `any more` pattern is used to catch arguments containing complex expressions with more than one token, preventing syntax like `INC A+0` or `INC A+B-A`. Whether to include this constraint depends on the instruction set and personal preference.

The condition `value eq value element 1` ensures that the value contains only a register name and no other terms. Even when an argument is restricted to a single token, it might still have a complex value if definitions like `X = A + B` or `Y = 2 * A` exist. In such cases, `INC X` and `INC Y` would cause the `element 1` operator to return `A`, which differs from the checked value.

If an instruction accepts a variable number of arguments, a simple way to recognize its different forms is to declare an argument with the `&` modifier. This passes the complete contents of the arguments to `match`:

```assembly
element CC

NZ? := CC + 000b
Z?  := CC + 001b
NC? := CC + 010b
C?  := CC + 011b
PO  := CC + 100b
PE  := CC + 101b
P   := CC + 110b
M   := CC + 111b

macro CALL? arguments&
    local cc,nn
    match condition =, target, arguments
        cc = condition - CC
        nn = target
        db 0C4h + cc shl 3
    else
        nn = arguments
        db 0CDh
    end match
    dw nn
end macro

CALL 0
CALL NC,2135h
```

This approach also handles more complex scenarios where arguments might contain commas or have different delimiters.

<br>

# How are labels processed?

The standard way to define a label is by appending a colon `:` to its name. This also acts as a line break, allowing other commands, including more labels, to follow on the same line. Such a label defines a symbol with a value equal to the current address, which starts at zero and increments as bytes are added to the output.

Some assembly language variants allow labels to precede instructions without an intervening `:`. To support this, a labeled macroinstruction can be created, which defines a label and then passes control to the original macroinstruction with the same name:

```assembly
struc INC? argument
    .:
    INC argument
end struc

start   INC A
        INC B
```

This needs to be done for each instruction where this syntax is desired. A simple loop can automate this:

```assembly
iterate instruction, EX,INC,CALL
    struc instruction? argument
        .: instruction argument
    end struc
end iterate
```

Every built-in instruction that defines data already has a labeled variant.

By defining a labeled instruction with `?` as its name, it's possible to intercept every line that begins with an identifier that is not a known instruction. This identifier is then assumed to be a label. The following example allows labels without `:` to start any line in the source text. It also handles special cases where labels are followed by `:` or by `=` and a value, ensuring these still work correctly:

```assembly
struc ? tail&
    match :, tail
        .:
    else match : instruction, tail
        .: instruction
    else match == value, tail
        . = value
    else
        .: tail
    end match
end struc
```

With this global approach, defining specific labeled macroinstructions is no longer necessary. The choice between these methods depends on the desired syntax.

Intercepting even labels defined with `:` can be useful when the current address value needs additional processing before being assigned to a label. For example, if a processor uses addresses with a unit larger than a byte. The intercepting macroinstruction might then look like this:

```assembly
struc ? tail&
    match :, tail
        label . at $ shr 1
    else match : instruction, tail
        label . at $ shr 1
        instruction
    else
        . tail
    end match
end struc
```

The current address value used to define labels can be modified with `org`. To differentiate labels from absolute values, a symbol defined with `element` can be used to represent an address:

```assembly
element CODEBASE
org CODEBASE + 0

macro CALL? argument
    local value
    value = argument
    if value relativeto CODEBASE
        db 0CDh
        dw value - CODEBASE
    else if value relativeto 0
        db 0CDh
        dw value
    else
        err "incorrect argument"
    end if
end macro
```

To define labels in an address space that is not reflected in the output, a `virtual` block should be declared. The following example sets up macroinstructions `DATA` and `CODE` to switch between generating program instructions and data labels. Only instruction codes will be included in the output:

```assembly
element DATA
DATA_OFFSET = 2000h
element CODE
CODE_OFFSET = 1000h

macro DATA?
    _END
    virtual at DATA + DATA_OFFSET
end macro

macro CODE?
    _END
    org CODE + CODE_OFFSET
end macro

macro _END?
    if $ relativeto DATA
        DATA_OFFSET = $ - DATA
        end virtual
    else if $ relativeto CODE
        CODE_OFFSET = $ - CODE
    end if
end macro

postpone
    _END
end postpone

CODE
```

The `postpone` block ensures that the `virtual` block is always closed correctly, even if the source text ends with data definitions.

Within this environment, any instruction can distinguish between data labels and program labels. For instance, a branching instruction can be designed to accept either a program label or an absolute value as an argument, but disallow data labels:

```assembly
macro CALL? argument
    local value
    value = argument
    if value relativeto CODE
        db 0CDh
        dw value - CODE
    else if value relativeto 0
        db 0CDh
        dw value
    else
        err "incorrect argument"
    end if
end macro

DATA

variable db ?

CODE

routine:
```

In this context, `CALL routine` and `CALL 1000h` are valid, but `CALL variable` is not.

When labels have values that are not absolute numbers, relocations can be generated for instructions that use them. A special `virtual` block can store offsets of values within the program that need relocation when the program's base address changes:

```assembly
virtual at 0
    Relocations::
    rw RELOCATION_COUNT
end virtual

RELOCATION_INDEX = 0

postpone
    RELOCATION_COUNT := RELOCATION_INDEX
end postpone

macro WORD? value
    if value relativeto CODE
        store $ - CODE : 2 at Relocations : RELOCATION_INDEX shl 1
        RELOCATION_INDEX = RELOCATION_INDEX + 1
        dw value - CODE
    else
        dw value
    end if
end macro

macro CALL? argument
    local value
    value = argument
    if value relativeto CODE | value relativeto 0
        db 0CDh
        word value
    else
        err "incorrect argument"
    end if
end macro
```

The relocation table created in this way can be accessed with `load`. The following lines could place the entire table somewhere in the output:

```assembly
load RELOCATIONS : RELOCATION_COUNT shl 1 from Relocations : 0
dw RELOCATIONS
```

`load` reads the entire table into a single string, and then `dw` writes it to the output (padded to a word boundary if necessary, though in this case, padding is not required).

For more complex relocation types, additional modifiers might be needed. For example, if the upper and lower portions of an address need to be stored and relocated separately (perhaps across two instructions), modifiers can be implemented as follows:

```assembly
element MOD.HIGH
element MOD.LOW

HIGH? equ MOD.HIGH +
LOW? equ MOD.LOW +

macro BYTE? value
    if value relativeto MOD.HIGH + CODE
        ; register HIGH relocation
        db (value - MOD.HIGH - CODE) shr 8
    else if value relativeto MOD.LOW + CODE
        ; register LOW relocation
        db (value - MOD.LOW - CODE) and 0FFh
    else if value relativeto MOD.HIGH
        db (value - MOD.HIGH) shr 8
    else if value relativeto MOD.LOW
        db (value - MOD.LOW) and 0FFh
    else
        db value
    end if
end macro
```

The relocation registration commands are omitted for clarity. In a real implementation, not only the offset within the code but also additional information would need to be registered in appropriate structures. With this setup, relocatable units in code can be generated like:

```assembly
BYTE HIGH address
BYTE LOW address
```

This approach allows easily enabling syntax with modifiers in any instruction that internally uses the `byte` macroinstruction for code generation.

<br>

# How can multiple sections of file be generated in parallel?

This assembly engine has a single main output stream that must be generated sequentially. This might seem problematic when a file needs to contain distinct sections for code and data, especially when these sections are composed of interleaved pieces spread across multiple source files. However, several methods address this, all leveraging the assembler's forward-referencing capabilities.

A natural approach is to define the contents of auxiliary sections within `virtual` blocks and then copy them to the appropriate output position in a single operation. When a `virtual` block is labeled, it can be re-opened multiple times to append more data.

```assembly
include '8086.inc'
org     100h
jmp     CodeSection

DataSection:

    virtual
        Data::
    end virtual

    postpone
        virtual Data
            load Data.OctetString : $ - $$ from $$
        end virtual
    end postpone

    db Data.OctetString

CodeSection:

    virtual Data
        Hello db "Hello!",24h
    end virtual

    mov     ah,9
    mov     dx,Hello
    int     21h

    virtual Data
        ExitCode db 37h
    end virtual

    mov     ah,4Ch
    mov     al,[ExitCode]
    int     21h
```

This method results in a relatively simple syntax, even without additional macros.

Another method is to encapsulate section pieces within macros and execute them all at the desired location in the source. A potential drawback of this approach is that tracing errors in definitions might become slightly more complex.

Techniques for easily appending to a section generated in parallel are also very useful for creating data structures like relocation tables. Instead of `store` commands as used earlier, regular data directives can be used inside a re-opened `virtual` block to create relocation records.

<br>

# What options are there to parse other kinds of syntax?

In some cases, assembler commands might start with something other than an instruction name or label. A name might be preceded by a special character like `.` or `!`, or it could be an entirely different kind of construction. In these situations, `macro ?` can be used to intercept entire lines of source text and handle such special syntax.

For example, to allow a command like `.CODE`, it cannot be directly implemented as a macroinstruction because the initial dot makes the symbol local. A globally defined instruction could never be executed this way. An intercepting macroinstruction provides a solution:

```assembly
macro ? line&
    match .=CODE?, line
        CODE
    else match .=DATA?, line
        DATA
    else
        line
    end match
end macro
```

Lines containing `.CODE` or `.DATA` are processed to invoke the global macroinstruction with the corresponding name. All other intercepted lines are executed without modification. This method allows filtering out special syntax while letting the assembler process regular instructions normally.

Sometimes, unconventional syntax is only expected within a specific area of the source text, such as inside a defined block. The parsing macroinstruction should then be applied only in this region and removed with `purge` when the block ends:

```assembly
macro concise
    macro ? line&
        match =end =concise, line
            purge ?
        else match dest+==src, line
            ADD dest,src
        else match dest-==src, line
            SUB dest,src
        else match dest==src, line
            LD dest,src
        else match dest++, line
            INC dest
        else match dest--, line
            DEC dest
        else match any, line
            err "syntax error"
        end match
    end macro
end macro

concise
    C=0
    B++
    A+=2
end concise
```

A macroinstruction defined this way does not intercept directives that control assembly flow, like `if` or `repeat`, which can still be used freely within the block. This behavior changes if the declaration were `macro ?! line&`. This variant would intercept every line without exception.

Another option to catch special commands is using `struc ?` to intercept only lines that do not begin with a known instruction (the initial symbol is then treated as a label). Since this only tests unknown commands, it should have less overhead during assembly:

```assembly
struc (head) ? tail&
    match .=CODE?, head
        CODE tail
    else
        head tail
    end match
end struc
```

All these approaches have a subtle pitfall. A label defined with `:` can be followed by another instruction on the same line. If that subsequent instruction (which becomes hidden in the `tail` parameter) is a control directive like `if`, placing it inside the `else` clause can break the nesting of control blocks. A solution is to invoke the `tail` contents outside the `match` block. One way is to call a special macro:

```assembly
struc (head) ? tail&
    local invoker
    match .=CODE?, head
        macro invoker
            CODE tail
        end macro
    else
        macro invoker
            head tail
        end macro
    end match
    invoker
end struc
```

A simpler option is to call the original line directly. When an override is needed, it can be ignored using another line interceptor that immediately removes itself:

```assembly
struc (head) ? tail&
    match .=CODE?, head
        CODE tail
        macro ? line&
            purge ?
        end macro
    end match
    head tail
end struc
```

However, a much better way to avoid these kinds of issues is to use CALM instructions instead of standard macros. CALM instructions allow processing arguments and assembling the original or modified line without control directives. They also offer significantly better performance, which is especially important for interceptors called for almost every line of source text.

<br>

# How to define an instruction sharing a name with one of the core directives?

It may happen that a language can be easily implemented with macros, but it needs a command with the same name as an assembler directive. While any instruction can be overridden with a macro, macros might still need access to the original directive. To allow the same name to call different instructions depending on context, the implemented language can be interpreted within a namespace containing the overriding macro. Macros needing access to the original directive would then temporarily switch to another namespace where it's not overridden. This requires each such macro to enclose its contents in a `namespace` block.

However, there is another technique related to how macro parameter texts or symbolic variables preserve the context in which symbols within them should be interpreted (including the base namespace and the parent label for symbols starting with a dot).

Unlike parameters and symbolic variables, macro text normally does not carry this extra context information. But if a macro is constructed to contain text that was once within a parameter of another macro or a symbolic variable, that text retains context information even when it becomes part of a newly defined macro. For example:

```assembly
macro definitions end?
    namespace embedded
    struc LABEL? size
        match , size
            .:
        else
            label . : size
        end match
    end struc
    macro E#ND? name
        end namespace
        match any, name
            ENTRYPOINT := name
        end match
        macro ?! line&
        end macro
    end macro
end macro

definitions end

start LABEL
END start
```

The parameter given to the `definitions` macro might seem to do nothing as it replaces every instance of "end" with the same word. However, the text from the parameter is imbued with additional context information. This attribute is then preserved when the text becomes part of a new macro. Because of this, the `LABEL` macro can be used within a namespace where the `end` instruction has a different meaning. Yet, instances of `end` within its body still refer to the symbol in the outer namespace.

In this example, the parameter is case-insensitive, and thus, it would replace even the "END" in the `macro` statement intended to define a symbol in the `embedded` namespace. To prevent this, the identifier is split using a concatenation operator to avoid parameter recognition. This wouldn't be necessary if the parameter were case-sensitive (which is more typical).

The same effect can be achieved using symbolic variables instead of macro parameters, with `match` to extract the text of a symbolic variable:

```assembly
define link end
match end, link
    namespace embedded
    struc LABEL? size
        match , size
            .:
        else
            label . : size
        end match
    end struc
    macro END? name
        end namespace
        match any, name
            ENTRYPOINT := name
        end match
        macro ?! line&
        end macro
    end macro
end match

start LABEL
END start
```

This only works by passing the text through a symbolic variable. Parameters defined by control directives like `match` do not add context information to text unless it was already present.

CALM instructions offer another approach to these problems. If a customized instruction set is entirely defined using CALM, access to original control directives might not be needed. However, if a CALM instruction needs to assemble a directive that might be inaccessible, the symbolic variable passed to `assemble` should be defined with the appropriate context for the instruction symbol.

<br>

# How to convert a macroinstruction to CALM?

A classic macroinstruction consists of text lines preprocessed by replacing parameter names with their values each time the instruction is called. These preprocessed lines are then passed to the assembler. For example, this macroinstruction generates a single line for assembly by replacing "value" with the text provided as the argument:

```assembly
macro octet value*
    db value
end macro
```

A CALM instruction can be viewed as a custom preprocessor written in a special language. It uses commands to process arguments and generate lines for assembly. At a basic level, it can simulate standard preprocessing using the `arrange` command. After preprocessing a line, it must be explicitly passed to the assembler using the `assemble` command:

```assembly
calminstruction octet value*
    arrange value, =db value
    assemble value
end calminstruction
```

This provides the same result as the original macroinstruction, performing the same kind of preprocessing. However, unlike macroinstruction text, the pattern given to `arrange` must explicitly indicate which name tokens should be replaced with their values and which (prefixed with `=`) should be left untouched. Tokens copied from the pattern are stripped of context information, similar to how macroinstruction text normally carries no context. Values from arguments, however, retain the recognition context from when the instruction was initiated.

This is the most direct conversion method. A simple sequence of `arrange` and `assemble` commands can generate the same lines as the original macroinstruction. One exception is when a `local` command is executed by a macroinstruction. This creates a preprocessed parameter with a special value pointing to a symbol in a namespace unique to that instruction instance.

```assembly
macro pointer
    local next
    dd next
next:
end macro
```

CALM instructions do not have such a namespace. The local namespace of a CALM instruction is shared among all instances. Therefore, if a unique symbol is needed each time the instruction is called, it must be constructed manually. A common method is to append a unique number to the name:

```assembly
global_uid = 0

calminstruction pointer
    compute global_uid, global_uid + 1
    local command
    arrange command, =dd =next#global_uid
    assemble command
    arrange command, =next#global_uid:
    assemble command
end calminstruction
```

Here, `arrange` is given a variable with a numeric value, which it replaces with text. This works only for plain non-negative numbers, which `arrange` converts to a decimal text representation. The lines passed to assembly will then contain identifiers like `next#1`.

While incrementing the global counter could be done by preparing a standard assembly command like `global_uid = global_uid + 1` with `arrange` and passing it to assembly, the `compute` command allows direct execution within the CALM processor. Furthermore, `compute` is unaffected by anything altering the assembly context. If the instruction is unconditional and used inside a skipped `IF` block, `compute` will still execute. CALM command execution, like standard preprocessing, is independent of the main assembly flow. Also, references to `global_uid` always point to the same symbol â€“ the one in scope when the CALM instruction was defined and compiled. Incrementing the value with `compute` is therefore more reliable and predictable.

Similarly, assembling a line defining a label can be replaced with a `publish` command. The label's value (which should be the address after the `dd` line is assembled) needs to be computed first because `publish` only assigns a value to a symbol:

```assembly
global_uid = 0

calminstruction pointer
    compute global_uid, global_uid + 1
    local symbol, command
    arrange symbol, =next#global_uid
    assemble command
    local address
    compute address, $
    publish symbol:, address
end calminstruction
```

Because the CALM instruction itself is conditional, `publish` inside it is also effectively conditional, making it a correct replacement for assembling a label line.

While a global counter has advantages, interference is possible. Using a local counter might be preferable, but the local namespace of a CALM instruction is not normally accessible externally. Initializing a local counter is thus slightly more challenging. One approach is to check if the counter is already initialized using the `take` command:

```assembly
calminstruction pointer
    local id
    take id, id
    jyes increment
    compute id, 0
increment:
    compute id, id + 1
    local symbol, command
    arrange symbol, =next#id
    assemble command
    local address
    compute address, $
    publish symbol:, address
end calminstruction
```

However, this adds commands executed every time the instruction is called. A better solution uses custom instructions processed during CALM instruction definition:

```assembly
calminstruction calminstruction?.init? var*, val:0
    compute val, val
    publish var, val
end calminstruction

calminstruction pointer
    local id
    init id, 0
    compute id, id + 1
    local symbol, command
    arrange symbol, =next#id
    assemble command
    local address
    compute address, $
    publish symbol:, address
end calminstruction
```

The custom statement `init` is called when the CALM instruction is *defined* (it does not generate commands for the defined instruction; it would need to use `assemble` to generate statements to be compiled). It receives a variable name from the CALM instruction's local scope and uses `publish` to assign an initial numeric value.

To initialize a local variable with a symbolic value, an even simpler custom instruction suffices:

```assembly
calminstruction calminstruction?.initsym? var*, val&
    publish var, val
end calminstruction
```

The `val` argument text carries the recognition context of the CALM instruction definition containing the `initsym` statement. This allows preparing text for `assemble` that references local symbols:

```assembly
calminstruction be32? value
    local command
    initsym command, dd value
    compute value, value bswap 4
    assemble command
end calminstruction
```

After compilation, this instruction contains only two actual commands: `compute` and `assemble`. The local symbol `command`'s value is text interpreted in the same local context and refers to the same `value` symbol as `compute`.

This example also highlights another CALM advantage over standard macroinstructions: its strict semantics prevent unwanted behaviors permitted by simple text substitution. The `value` text will be evaluated by `compute` as a numeric sub-expression, signaling an error for unexpected syntax. Processing arguments entirely through CALM commands and using `assemble` only for final simple statements is therefore preferable.
